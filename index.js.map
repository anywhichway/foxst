{"mappings":"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","sources":["src/index.js"],"sourcesContent":["\r\nconst serializer = (options=false) => {\r\n    const {functions=options,regexs=options,infinity=options,nan=options,builtins=options} = typeof(options)===\"boolean\" ? {} : options;\r\n    return function serialize(key,value) {\r\n        const type = typeof(value);\r\n        if((functions && type===\"function\") || (regexs && value && type===\"object\" && value instanceof RegExp)) {\r\n            return value+\"\";\r\n        }\r\n        if((infinity && (value===Infinity || value===-Infinity)) || (nan && type===\"number\" && isNaN(value))) {\r\n            return \"@\"+value+\"@\";\r\n        }\r\n        if(value && type===\"object\") {\r\n            if(value instanceof Set) {\r\n                return builtins ? JSON.stringify([\"@Set@\",...value.values()],serialize) : undefined;\r\n            }\r\n            if(value instanceof Map) {\r\n                return builtins ? JSON.stringify([\"@Map@\",...value.entries()],serialize) : undefined;\r\n            }\r\n            if([Int8Array,Int16Array,Int32Array,Uint8Array,Uint16Array,Uint32Array].some((ctor) =>value instanceof ctor)) {\r\n                return builtins ? JSON.stringify([\"@\"+value.constructor.name+\"@\",...value],serialize) : undefined\r\n            }\r\n            if(value.constructor.name!==\"Array\" && (value instanceof Array || Array.isArray(value))) {\r\n                return JSON.stringify([\"@\"+value.constructor.name+\"@\",...value],serialize)\r\n            }\r\n            if(!Array.isArray(value) && value.constructor.name && value.constructor.name!==\"Object\") {\r\n                const object = Object.entries(value).reduce((object,[key,value]) => {\r\n                    const type = typeof(value);\r\n                    if(value && type===\"object\") {\r\n                        object[key] = JSON.stringify(value,serialize);\r\n                    } else if((type===\"function\" && functions) || (type===\"number\" && ((infinity && (value==Infinity || value===-Infinity)) || (nan && isNaN(value))))) {\r\n                        object[key] = value+\"\";\r\n                    } else {\r\n                        object[key] = value;\r\n                    }\r\n                    return object;\r\n                }, {});\r\n                return [\"@\"+value.constructor.name+\"@\",object]\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n}\r\n\r\nconst reviver = (options=false,ctors={}) => {\r\n    const {functions=options,regexs=options,infinity=options,nan=options,builtins=options,autocreate=options} = typeof(options)===\"boolean\" ? {} : options;\r\n    return function revive(key,value) {\r\n        if(typeof(value)===\"string\") {\r\n            if (infinity) {\r\n                if (value === \"@Infinity@\") return Infinity;\r\n                if (value === \"@-Infinity@\") return -Infinity;\r\n            }\r\n            if (nan && value === \"@NaN@\") {\r\n                return NaN;\r\n            }\r\n            if (regexs && value.match(/\\/.*\\/[gimusy]*/)) {\r\n                const [_, pattern, flags, ...rest] = value.split(\"/\");\r\n                if (rest.length === 0) {\r\n                    try {\r\n                        return new RegExp(pattern, flags);\r\n                    } catch (e) {\r\n\r\n                    }\r\n                }\r\n                return value;\r\n            }\r\n            if(value[0]===\"[\" && value[value.length-1]===\"]\") {\r\n                try {\r\n                    return JSON.parse(value,revive);\r\n                } catch(e) {\r\n                    return value;\r\n                }\r\n            }\r\n            if(functions && (value.match(/function\\s?[A-Z0-9_$]*\\(.*\\)\\s?\\{.*\\}/gi) || value.match(/\\(.*\\)\\s?=>\\{?.*\\}?/g))) {\r\n                try {\r\n                    const result = new Function(\"return \" + value)(),\r\n                        type = typeof(result);\r\n                    if(type===\"function\") {\r\n                        return result;\r\n                    }\r\n                } catch(e) {\r\n\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n        if(Array.isArray(value)) {\r\n            const [first,...rest] = value;\r\n            if(typeof(first)===\"string\" && first.match(/@[A-Z$][A-Za-z0-9$_]*@/g)) {\r\n                const cname = first.substring(1,first.length-1);\r\n                if(builtins) {\r\n                    if(cname===\"Set\") {\r\n                        return new Set(rest);\r\n                    }\r\n                    if(cname===\"Map\") {\r\n                        return new Map(rest);\r\n                    }\r\n                }\r\n                const arrays = {\r\n                    Int8Array,\r\n                    Int16Array,\r\n                    Int32Array,\r\n                    Uint8Array,\r\n                    Uint16Array,\r\n                    Uint32Array\r\n                    },\r\n                    constructors = Object.assign({\r\n                        ...ctors\r\n                    },builtins ? arrays : undefined);\r\n                let ctor = constructors[cname] || globalThis[cname];\r\n                if(!ctor && autocreate && rest.length===1 && rest[0] && typeof(rest[0])===\"object\") {\r\n                    ctor = globalThis[cname] = Function(`return function ${cname}(config) { return this instanceof ${cname} ? Object.assign(this,config) : new ${cname}(config); }`)();\r\n                }\r\n                if(ctor) {\r\n                    let object = Object.create(ctor.prototype);\r\n                    Object.defineProperty(object,\"constructor\",{value:ctor,enumerable:false});\r\n                    if(arrays[ctor.name] ||  [Int8Array,Int16Array,Int32Array,Uint8Array,Uint16Array,Uint16Array].some((ctor) => object instanceof ctor)) {\r\n                        return Object.assign(object,rest);\r\n                    }\r\n                    if(object instanceof Array || Array.isArray(object)) {\r\n                        try {\r\n                            object =  new ctor();\r\n                        } catch(e) {\r\n\r\n                        }\r\n                        return Object.assign(object,rest);\r\n                    }\r\n                    if(rest[0] && typeof(rest[0])===\"object\") {\r\n                        Object.entries(rest[0]).forEach(([key, value]) => {\r\n                            if(key===\"constructor\") {\r\n                                return;\r\n                            }\r\n                            try {\r\n                                try {\r\n                                    value = typeof(value)===\"string\" ? JSON.parse(value,revive) : value;\r\n                                } catch(e) {\r\n\r\n                                }\r\n                                object[key] = value;\r\n                            } catch (e) {\r\n\r\n                            }\r\n                        });\r\n                    }\r\n                    return object;\r\n                }\r\n                if(rest.length===1 && rest[0] && typeof(rest[0])===\"object\") {\r\n                    return Object.assign({},rest[0]);\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n}\r\n\r\nconst getKeyMatcher = (key) => {\r\n    try {\r\n        const result = new Function(\"return \" + key)(),\r\n            type = typeof(result);\r\n        if(type===\"function\") {\r\n            return result;\r\n        }\r\n        if(result && type===\"object\" && result instanceof RegExp) {\r\n            return (key) => result.test(key);\r\n        }\r\n    } catch(e) {\r\n\r\n    }\r\n}\r\n\r\nconst getValueMatcher = (value) => {\r\n    const type = typeof(value);\r\n    if(type===\"function\") {\r\n        return value;\r\n    }\r\n    if(value && type===\"object\" && value instanceof RegExp) {\r\n        return (v) => typeof(v)===\"string\" ? (v.match(value)||[])[0]  : undefined;\r\n    }\r\n    // objects should always match since the outer algorithm recurses down\r\n    return (v) => v === value || (v && typeof(v)===\"object\" && value && typeof(value)===\"object\") ? v : undefined;\r\n}\r\n\r\nfunction xt(pattern,target) {\r\n    if(pattern===target) {\r\n        return target;\r\n    }\r\n    const type = typeof(pattern);\r\n    if(type===\"function\") {\r\n        try {\r\n            return pattern(target);\r\n        } catch(e) {\r\n            return;\r\n        }\r\n    }\r\n    if(pattern && type===\"object\") {\r\n        if(pattern instanceof RegExp) {\r\n            return typeof(target)===\"string\" ? (target.match(pattern)||[])[0]  : undefined;\r\n        }\r\n        if(!target || typeof(target)!==\"object\") {\r\n            return;\r\n        }\r\n        return Object.entries(pattern).reduce((result,[key,value]) => {\r\n            const keymatcher = getKeyMatcher(key),\r\n                valuematcher = getValueMatcher(value);\r\n            if(value && typeof(value)===\"object\") {\r\n                if(typeof(keymatcher)===\"function\") {\r\n                    Object.entries(target).forEach(([key,value]) => {\r\n                        if(keymatcher.call(target,key)) {\r\n                            value = valuematcher(value);\r\n                            if(value!==undefined) {\r\n                                result ||= {};\r\n                                result[key] =  value;\r\n                            }\r\n                        }\r\n                    })\r\n                } else {\r\n                    value = xt(value,valuematcher(target[key]));\r\n                    if(value!==undefined) {\r\n                        result ||= {};\r\n                        result[key] =  value;\r\n                    }\r\n                }\r\n            } else if(typeof(keymatcher)===\"function\") {\r\n                Object.entries(target).forEach(([key,value]) => {\r\n                    if(keymatcher.call(target,key)) {\r\n                        value = valuematcher(value);\r\n                        if(value!==undefined) {\r\n                            result ||= {};\r\n                            result[key] =  value;\r\n                        }\r\n                    }\r\n                })\r\n            } else {\r\n                value = valuematcher(target[key]);\r\n                if(value!==undefined) {\r\n                    result ||= {};\r\n                    result[key] =  value;\r\n                }\r\n            }\r\n            return result;\r\n        },null)\r\n    }\r\n}\r\n\r\n\r\nconst FOXST = {\r\n    serializer,\r\n    reviver,\r\n    xt\r\n}\r\n\r\nexport {serializer,reviver,xt,FOXST as default}"],"names":[],"version":3,"file":"index.js.map"}